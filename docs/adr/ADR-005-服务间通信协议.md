# ADR-005: 服务间通信协议

## 状态
已接受

## 上下文

ADR-004 已明确服务间以 **REST over HTTP** 通信，Kong、Consul 的职责及超时、重试、熔断等策略。进入 Day 3 实现阶段，需在**协议级**约定：各服务间调用的具体端点、请求/响应结构、HTTP Header、以及当前 OpenAPI 中的缺口（如 支付→核心银行 的扣款接口），以便 Agent 1、2、3 实现时一致，并与 `agent-dependency-matrix`、`api-design-spec-v1.0` 对齐。

## 审查与审批结论（对应决策窗口 1 任务 1、2）

### 1. 各服务 API 设计审查

| 服务 | OpenAPI | 实现进度（Day 3 初） | 结论 |
|------|---------|---------------------|------|
| **核心银行** | `core-bank-service/docs/openapi.yaml` | 实体/Repository 已有；AccountService、Controller 待实现或进行中 | **通过**。路径 `/api/v1/accounts`、`/api/v1/customers`、`/api/v1/transactions` 符合 api-design-spec；枚举、分页、ErrorResponse 与 data-dictionary、technical-standards 一致。**缺口**：支付→核心银行 **扣款** 无独立端点，见下节。 |
| **支付** | `payment-service/docs/openapi.yaml` | Payment/Settlement 模型、路由、Mock 网关已有；process 流程中对核心银行、风控的调用待实现 | **通过**。`/api/v1/payments`、`/api/v1/settlements` 符合规范；CreatePaymentRequest 含 `accountId`，与扣款联动。 |
| **风控** | `risk-service/docs/openapi.yaml` | 规则引擎、RiskCheck、黑名单结构已有；`/api/v1/risk/check`、`/api/v1/risk/blacklist` 已定义 | **通过**。`RiskCheckRequest` 为 snake_case（`customer_id`、`account_id`）；200/403/500、ErrorResponse、RKB001 等符合。**约定**：调用方（核心银行、支付）按 RiskCheckRequest 的 snake_case 传参，或与 Agent 3 约定后在风控侧做 camelCase 兼容。 |

### 2. 服务间接口协议审批

以下服务间契约**批准**作为实现基准；与 ADR-004、api-design-spec-v1.0 一致。

---

## 决策

### 服务间接口契约表

| 调用方 | 被调方 | 场景 | 方法 | 路径 | 请求体/参数 | 响应 | 说明 |
|--------|--------|------|------|------|-------------|------|------|
| **核心银行** | 风控 | 行内转账前风控 | POST | `/api/v1/risk/check` | `RiskCheckRequest`（customer_id, account_id, amount, transaction_type=transfer, recipient_account_id 等） | 200 + RiskCheckResult；403 风控拦截 | 转账前调用；403 时核心银行拒绝转账 |
| **支付** | 风控 | 支付处理前风控 | POST | `/api/v1/risk/check` | `RiskCheckRequest`（customer_id, account_id, amount, transaction_type=payment 等） | 200 + RiskCheckResult；403 风控拦截 | 支付前调用；403 时支付拒绝并置为 failed |
| **支付** | 核心银行 | 余额查询 | GET | `/api/v1/accounts/{account-id}/balance` | path: account-id | 200 { accountId, balance, currency } | 扣款前校验余额；account-id 与 CreatePaymentRequest.accountId 对应（需为数字 id，若支付侧为字符串则需映射） |
| **支付** | 核心银行 | 支付扣款 | 见下节 | — | — | — | **当前 OpenAPI 无专有扣款端点，需在核心银行补足或约定** |

### 支付→核心银行「扣款」接口约定

- **需求**：支付在 `processPayment` 中需对 `accountId` 对应账户做**扣款**（transaction_type=payment），并取得 `transactionId` 以便对账与冲正。
- **方案一（推荐）**：核心银行新增 **POST /api/v1/transactions/debit**，**仅服务间**，不在对外 OpenAPI 暴露或加 tag「内部」。
  - **Request**: `{ "accountId": long, "amount": number, "refId": string, "remark": string? }`（refId 如 paymentId，用于幂等与对账）
  - **Response**: 201 `{ "transactionId": string, "accountId": long, "amount": number, "status": "completed" }`；400 余额不足等；404 账户不存在。
  - **幂等**：同一 `refId` 多次请求返回同一 `transactionId`，不重复扣款。
- **方案二（过渡）**：若 Day 3 不新增路径，则约定 核心银行 设一「支付备付金」内部户，支付调用 **POST /api/v1/transactions/transfer**：`fromAccountId=用户账户`，`toAccountId=备付金户`，`remark` 含 `paymentId`；核心银行在 OpenAPI 的该操作 `description` 中标明「服务间支付扣款可复用本接口，toAccountId 为系统内部户」。
- **审批结论**：**批准方案一**；若 Day 3 内实现不及，可暂用方案二，但须在 Day 4 前在核心银行 OpenAPI 与实现中补齐 **POST /api/v1/transactions/debit**，并废弃对 transfer 的该用法。

### 协议与格式（与 ADR-004、api-design-spec 一致）

- **协议**：HTTP/1.1，JSON；`Content-Type: application/json`；UTF-8；日期 ISO 8601。
- **超时**：服务间调用 10s；风控检查 2s 内返回为佳。
- **重试**：幂等操作（如 balance、risk/check）可重试，最多 3 次、指数退避；扣款等非幂等由调用方保证至少一次、被调方按 refId 幂等。
- **Header**：`X-Request-ID`、`X-Trace-ID`（或 `traceId`）透传；`X-Caller-Service: core-bank-service | payment-service` 便于风控/核心银行日志。
- **错误**：4xx/5xx + 统一 ErrorResponse（code、message、errorCode、timestamp）；风控 403 即拒绝，核心银行/支付据此中断流程。

### 风控 RiskCheckRequest 字段约定

- 风控 OpenAPI 使用 **snake_case**（`customer_id`、`account_id`、`transaction_type`、`recipient_account_id`）。
- **核心银行、支付** 调用时须按上述字段名传 JSON；若后续风控兼容 camelCase，由 Agent 3 在 OpenAPI 中注明，调用方可不改。

---

## 服务依赖与协调（对应决策窗口 1 任务 4）

与 `docs/architecture/agent-dependency-matrix.md` 对齐，并满足**无循环依赖**。

### 调用方向（与 ADR-004、agent-dependency-matrix 2.2、6.2 一致）

```
前端 → Kong → 核心银行、支付、风控（对外 API）

核心银行 → 风控：POST /api/v1/risk/check（转账前）
支付     → 风控：POST /api/v1/risk/check（支付前）
支付     → 核心银行：GET /api/v1/accounts/{id}/balance；POST /api/v1/transactions/debit（或过渡期 transfer）
```

- **风控**：仅被核心银行、支付调用；不主动调核心银行/支付做业务写操作。与矩阵 6.2「存在业务层面的相互调用，但非循环依赖」一致。
- **支付 → 核心银行**：仅 查询余额、扣款（及后续可能的冲正）；核心银行不调用支付，故无循环。

### 循环依赖检查

- **结论**：**无循环依赖**。
- 风控不调用核心银行/支付；核心银行不调用支付；支付调用核心银行与风控，二者均不回调支付。矩阵 6.2 中「A1→A3、A2→A3、A2→A1」为单向，与本 ADR 一致。

### 与 agent-dependency-matrix 的协调要点

- **2.2 业务依赖**：  
  - A2→A1 账户API（查询/扣款）：本 ADR 约定为 `GET /api/v1/accounts/{id}/balance`、`POST /api/v1/transactions/debit`（或过渡 transfer）。  
  - A1→A3、A2→A3：本 ADR 约定为 `POST /api/v1/risk/check`。  
- **6.3 关键依赖路径**：转账、支付路径与本节一致；SLA 仍按 ADR-004（入站 P95 &lt; 2s）、technical-standards 执行。
- **变更**：上述任一服务间接口的 path、方法、Request/Response 变更，须经 Agent 0 审批并更新本 ADR 与对应 OpenAPI。

---

## 后果

### 正面影响

1. 核心银行、支付、风控在实现服务间调用时有明确契约，减少联调歧义。
2. 支付→核心银行 扣款 的缺口通过 **POST /api/v1/transactions/debit** 或过渡方案明确，便于 Agent 1、2 排期。
3. 与 ADR-004、api-design-spec、agent-dependency-matrix 一致，无循环依赖，满足架构合规。

### 负面影响

1. 核心银行需新增 debit 接口或在 transfer 上约定内部户用法，有实现成本；过渡方案会带来技术债，需在 Day 4 前清偿。
2. 风控 RiskCheckRequest 为 snake_case，核心银行/支付需单独组包，若日后风控兼容 camelCase 可减轻。

### 风险缓解

1. Agent 1 在核心银行 OpenAPI 中补充 `POST /api/v1/transactions/debit` 的 YAML（或过渡期在 transfer 的 description 注明服务间用法），并实现；Agent 2 在 process 中按契约调用。
2. Agent 3 在 `risk/check` 的 description 中写明「供核心银行、支付服务间调用」，与 ADR-004、Day 2 简报建议一致。
3. 服务间调用需注入 traceId、caller 等 Header，便于 Day 5 及之后的排障与监控。

---

## 日期

2026-01-26

## 相关文档

- ADR-004: 服务间通信方式  
- api-design-spec-v1.0: `docs/architecture/api-design-spec-v1.0.md`  
- agent-dependency-matrix: `docs/architecture/agent-dependency-matrix.md`  
- core-bank-service: `core-bank-service/docs/openapi.yaml`  
- payment-service: `payment-service/docs/openapi.yaml`  
- risk-service: `risk-service/docs/openapi.yaml`  
